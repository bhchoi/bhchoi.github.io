I"p<blockquote>
  <p>Python Clean Code 책 내용 정리 노트 입니다.</p>
</blockquote>

<h1 id="chapter2-파이썬스러운pythonic-코드">Chapter2 파이썬스러운(pythonic) 코드</h1>
<p>파이썬스러운(pythonic) 관용구(idiom)를 사용했을때의 장점</p>
<ul>
  <li>더 좋은 성능을 낸다.</li>
  <li>코드가 작고 이해하기 쉽다.</li>
  <li>동일한 패턴과 구조에 익숙해지면 실수가 줄고, 본질적인것에 집중할 수 있다.</li>
</ul>

<h2 id="인덱스와-슬라이스">인덱스와 슬라이스</h2>
<h3 id="마지막-요소-인덱스">마지막 요소 인덱스</h3>
<p>C에서 배열의 마지막 요소에 접근하려면 배열의 길이에서 1을 뺀 위치에서 요소를 가져온다.<br />
하지만 파이썬에서는 음수 인덱스를 사용하여 끝에서부터 접근이 가능하다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="n">my_numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">my_numbers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
<span class="c1"># 9
</span><span class="n">my_numbers</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> 
<span class="c1"># 5
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="특정-구간-슬라이스">특정 구간 슬라이스</h3>
<p>대괄호의 시작 인덱스부터 종료 인덱스까지의 값을 가져온다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="n">my_numbers</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">21</span><span class="p">)</span>
<span class="n">my_numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> 
<span class="c1">#(2, 3, 5)
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>시작, 끝 인덱스를 제외할 수 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre><span class="n">my_numbers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># (1, 1, 2)
</span><span class="n">my_numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
<span class="c1"># (3, 5, 8, 13, 21)
</span><span class="n">my_numbers</span><span class="p">[::]</span>
<span class="c1"># (1, 1, 2, 3, 5, 8, 13, 21)
</span><span class="n">my_numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">7</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># 1부터 7까지의 요소 중 2칸씩 점프
# (1, 3, 8)
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>시퀀스에 간격을 전달하는 것은 slice 객체를 전달하는 것과 같다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre><span class="n">interval</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">my_numbers</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span>
<span class="c1"># (1, 3, 8)
</span>
<span class="n">interval</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">my_numbers</span><span class="p">[</span><span class="n">interval</span><span class="p">]</span> <span class="o">==</span> <span class="n">my_numbers</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># True
</span></pre></td></tr></tbody></table></code></pre></div></div>
<h3 id="자체-시쿼스-생성">자체 시쿼스 생성</h3>
<p>인덱스와 슬라이스 기능은 __getitem__ 메서드를 통해 동작한다.<br />
사용자정의 클래스에서 __getitem__을 구현하는 경우 몇 가지 고려사항 해야될 사항이 있다.<br />
클래스가 표준 라이브러리 객체를 감싸는 경우 기본 객체에 위임할 수 있다.
아래의 경우 list에 존재하는 동일한 메소드를 호출한다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Item</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_values</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_values</span><span class="p">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>표준 라이브러리를 사용하지 않는 경우 아래의 사항을 지켜야 한다.</p>
<ol>
  <li>범위로 인덱싱하는 결과는 해당 클래스와 같은 타입의 인스턴스여야 한다.</li>
  <li>slice에 의해 제공된 범위는 파이썬이 하는 것처럼 마지막 요소는 제외해야 한다.</li>
</ol>

<h2 id="컨텍스트-관리자context-manager">컨텍스트 관리자(context manager)</h2>
<p>특정 동작 전후 작업에 유용한 기능이다.<br />
일반적으로 리소스 관리를 할 때 컨텍스트 관리자를 자주 사용한다. 예를 들어, 파일을 열고 작업을 한 후 누수를 막기위해 파일을 닫아야 한다.<br />
일반적인 방법은 다음과 같다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre><span class="n">fd</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">process_file</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">fd</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>파이썬스러운 방법은 다음과 같다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">fd</span><span class="p">:</span>
    <span class="n">process_file</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>with문(PEP-343)은 컨텍스트 관리자로 진입하게 되고 예외가 발생해도 자동으로 닫힌다.</p>

<p>컨텍스트 관리자는 __enter__와 __exit__ 두 개의 메소드로 구성된다. with 문의 __enter__ 메소드를 호출하고 as 이후 변수에 할당된다. (꼭 변수에 할당할 필요는 없다.)<br />
with 블록의 마지막 문장이 끝나면 컨텍스트가 종료되고 __exit__가 호출된다.</p>

<p>컨텍스트 관리자가 리소스관리에 자주 사용되지만, 전후 처리가 필요한 기능에 자체 컨텍스트 관리자를 구현할 수 있다.<br />
예를 들면, DB 백업 작업 시, 백업 전에 DB가 중지되어야 하고 백업 후에 DB가 실행되어야 하는 경우이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> --><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">stop_database</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s">"systemctl stop postgresql.service"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">start_database</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s">"systemctl start postgresql.service"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBHandler</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stop_database</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">ex_value</span><span class="p">,</span> <span class="n">ex_traceback</span><span class="p">):</span>
        <span class="n">start_database</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">db_backup</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s">"pg_dump database"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">DBHandler</span><span class="p">():</span>
        <span class="n">db_backup</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="컨텍스트-관리자-구현">컨텍스트 관리자 구현</h3>
<p>표준 라이브러리 contextlib를 사용하여 컨텍스트 관리자를 쉽게 구현할 수 있다.<br />
contextlib.contextmanager 데코레이터를 사용하여 다음과 같이 작성할 수 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="o">@</span><span class="n">contextlib</span><span class="p">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">db_handler</span><span class="p">():</span>
    <span class="n">stop_database</span><span class="p">()</span>
    <span class="k">yield</span>
    <span class="n">start_database</span><span class="p">()</span>

<span class="k">with</span> <span class="n">db_handler</span><span class="p">():</span>
    <span class="n">db_backup</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>yield를 사용하면 제너레이터 함수가 되며, yield 문의 앞 부분은 __enter__이 되고, 반환값을 지정할 수 있다.<br />
yield 뒷 부분은 __exit__가 된다.<br />
이렇게 작성하면 업무 도메인이 분리가 되어 리팩토링하기 편리한 장점이 있다.</p>

<p>컨텍스트 관리자를 구현하는 또 다른 방법은 contextlib.ContextDecorator이다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">dbhandler_decorator</span><span class="p">(</span><span class="n">contextlib</span><span class="p">.</span><span class="n">ContextDecorator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stop_database</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">ex_value</span><span class="p">,</span> <span class="n">ex_traceback</span><span class="p">):</span>
        <span class="n">start_database</span><span class="p">()</span>

<span class="o">@</span><span class="n">dbhandler_decorator</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">offline_backup</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s">"pg_dump database"</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>이 방법에는 with 문이 없다. 함수를 호출하면 자동으로 컨텍스트 관리자 안에서 실행된다.<br />
이 방법의 장점이자 단점은 완전히 독립적이라는 것이다. 데코레이터 함수에 대해 모르고 반대도 마찬가지이다. 대신 컨텍스트 관리자 내에서 사용할 수 있는 객체를 얻을 수 없다.</p>

<p>마지막으로 contextlib.suppress에 대해 알아보자.<br />
contextlib.suppress는 try/catch와 동일한 효과를 준다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="k">with</span> <span class="n">contextlib</span><span class="p">.</span><span class="n">suppress</span><span class="p">(</span><span class="n">DataConversionException</span><span class="p">):</span>
    <span class="n">parse_data</span><span class="p">(</span><span class="n">input_json_or_dict</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="프로퍼티-속성과-객체-메서드의-다른-타입들">프로퍼티, 속성과 객체 메서드의 다른 타입들</h2>
<p>파이썬 객체의 모든 프로퍼티와 메소드는 public이다. 강제사항은 없지만 몇 가지 규칙이 존재한다. <br />
예를 들어, 밑줄로 시작하는 속성은 private으로 취급한다. 밑줄에 대해 자세히 알아보자.</p>

<h3 id="파이썬에서의-밑줄">파이썬에서의 밑줄</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Connector</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_timeout</span> <span class="o">=</span> <span class="mi">60</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">Connector</span><span class="p">(</span><span class="s">"postgresql://localhost"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">source</span><span class="p">)</span>
<span class="c1"># postgresql://localhost
</span><span class="k">print</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">_timeout</span><span class="p">)</span>
<span class="c1"># 60
</span><span class="n">conn</span><span class="p">.</span><span class="n">__dict__</span>
<span class="c1"># {'source': 'postgresql://localhost', '_timeout': 60}
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>source는 public, _timeout은 private이지만 접근이 가능하다.<br />
_timeout은 connector 내부에서만 사용하고 외부에서 호출되어서는 안된다.<br />
이러한 규칙을 지킨다면 유지보수가 쉬워지고 견고한 코드를 작성할 수 있다.</p>

<p>이중 밑줄을 사용하여 private을 만들 수 있다는 오해가 있다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td> --><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Connector</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">__timeout</span> <span class="o">=</span> <span class="mi">60</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">Connector</span><span class="p">(</span><span class="s">"postgresql://localhost"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">source</span><span class="p">)</span>
<span class="c1"># postgresql://localhost
</span><span class="k">print</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">__timeout</span><span class="p">)</span>

<span class="n">Trackback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
    <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
    <span class="nb">AttributeError</span><span class="p">:</span> <span class="s">'Connector'</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s">'__timeout'</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>일부 개발자들은 이런 방식으로 속성을 숨길 수 있다고 생각하지만, AttributeError는 private이라서 발생하는 에러가 아니라 속성이 존재하지 않을 때 발생하는 에러이다.<br />
밑줄 두 개를 사용하면 파이썬은 다른 이름을 만든다. 이를 name mangling이라고 한다.<br />
‘_<class-name>__<attribute-name>" 속성이 만들어 진다.</attribute-name></class-name></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="k">print</span><span class="p">(</span><span class="n">conn</span><span class="p">.</span><span class="n">_Connector__timeout</span><span class="p">)</span>
<span class="c1"># 60
</span></pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="프로퍼티">프로퍼티</h3>
<p>객체의 어떤 속성에 접근할 때 다른 언어는 getter/setter를 사용하지만 파이썬은 프로퍼티를 사용한다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> --><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">re</span>

<span class="n">EMAIL_FORMAT</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">compiler</span><span class="p">(</span><span class="s">r"[^@]+@[^@]+[^@]+"</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">is_valid_email</span><span class="p">(</span><span class="n">potentially_valid_email</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">EMAIL_FORMAT</span><span class="p">,</span> <span class="n">potentially_valid_email</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_email</span> <span class="o">=</span> <span class="bp">None</span>

<span class="o">@</span><span class="nb">property</span>
<span class="k">def</span> <span class="nf">email</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_email</span>

<span class="o">@</span><span class="n">email</span><span class="p">.</span><span class="n">setter</span>
<span class="k">def</span> <span class="nf">email</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_email</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_email</span><span class="p">(</span><span class="n">new_email</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">f"유효한 이메일이 아니므로 </span><span class="si">{</span><span class="n">new_email</span><span class="si">}</span><span class="s"> 값을 사용할 수 없음"</span><span class="p">)</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">_email</span> <span class="o">=</span> <span class="n">new_email</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>@property 메소드는 private인 email 값을 반환한다.<br />
@email.setter는 user.email = <new_email>이 실행될 때 호출되는 메소드이다.</new_email></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="s">"jsmith"</span><span class="p">)</span>
<span class="n">u1</span><span class="p">.</span><span class="n">email</span> <span class="o">=</span> <span class="s">"jsmith@"</span>
<span class="n">Trackback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
<span class="p">...</span>
<span class="n">유효한</span> <span class="n">이메일이</span> <span class="n">아니므로</span> <span class="n">jsmith</span><span class="o">@</span> <span class="n">값을</span> <span class="n">사용할</span> <span class="n">수</span> <span class="n">없음</span>

<span class="n">u1</span><span class="p">.</span><span class="n">email</span> <span class="o">=</span> <span class="s">"jsmith@g.co"</span>
<span class="n">u1</span><span class="p">.</span><span class="n">email</span>
<span class="c1"># jsmith@g.co
</span></pre></td></tr></tbody></table></code></pre></div></div>
<p>일반적인 경우는 속성을 직접 사용하고, 속성 값을 가져오거나 수정할때 로직이 필요한 경우에 프로퍼티를 사용한다.</p>

<p>프로퍼티는 명령-쿼리 분리 법칙(command and query separation - CC08)을 따르는 좋은 방법이다. <br />
명령과 쿼리 중 하나만 수행해야지 둘 다 동시에 수행하면 안된다는 것이다.<br />
예를 들어, set_email(“a@j.com”)의 의미가 이메일을 설정하는 것인지, 확인하는 것인지, 둘 다 하는 것인지 혼동될 수 있다.<br />
프로퍼티를 사용하면 @property는 응답을 위한 쿼리이고, @<property_name>.setter는 무언가를 하기 위한 command이다.
추가적으로 메소드는 한 가지만 수행 해야하고, 작업을 처리한 다음 상태를 확인하려면 메소드를 분해야하 한다.</property_name></p>

<h2 id="이터러블-객체">이터러블 객체</h2>
<p>파이썬에서는 자체 이터러블을 만들 수 있다. 반복은 이터러블 프로토콜을 사용해 동작하며 다음 두 가지를 충족해야 한다.</p>
<ul>
  <li>객체가 __next__나 __iter__ 이터레이터 메소드 중 하나를 포함하는지 여부</li>
  <li>객체가 시퀀스이고 __len__과 __getitem__을 모두 가졌는지 여부</li>
</ul>

<h3 id="이터러블-객체-만들기">이터러블 객체 만들기</h3>
<p>객체를 반복할때 iter()를 호출하여 __iter__ 메소드가 있는지 확인한다.
다음은 일정 기간의 날짜를 하루 간격으로 반복하는 객체의 코드이다.</p>

<p>```python
from datetime import timedelta</p>

<p>class DateRangeIterable:
    “"”자체 이터레이터 메소드를 가지고 있는 이터러블</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>"""
</pre></td></tr></tbody></table></code></pre></div></div>
:ET